# TCP三次握手四次挥手(只要没收到确认消息就要重新发)

##  三次握手(既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求)

TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:

![](/home/xsh/桌面/markdown/imgs/TCPConnect.JPG)

tcp保温

![](/home/xsh/桌面/markdown/imgs/291246111727359.png)

### TCP的报头结构：

源端口 16位
目标端口 16位
序列号 32位
回应序号 32位
TCP头长度 4位
reserved 6位
控制代码 6位
窗口大小 16位
偏移量 16位
校验和 16位
选项 32位(可选)
这样我们得出了TCP包头的最小长度，为20字节

**SYN: 表示建立连接**

**FIN: 表示关闭连接**

**ACK: 表示响应**



#### SYN_SEND(1次握手,SYN=1, seq=x)

客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。

发送完毕后，客户端进入 `SYN_SEND` 状态。

#### SYN_RECV(2次握手,SYN=1, ACK=1, seq=y, ACKnum=x+1)(被打开端确认对方能发,并且自己能收,建立链接,响应)

服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态。

#### ESTABLISHED(3次握手,ACK=1,SYN=0,ACKnum=y+1)(打开端确认自己能发,并且确认自己能收,响应)

客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1

发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。

![](/home/xsh/桌面/markdown/imgs/100327002911.png)

　　

![](/home/xsh/桌面/markdown/imgs/100327003054 (1).png)





![](/home/xsh/桌面/markdown/imgs/100327003214.png)





### SYN攻击

#### 什么是 SYN 攻击（SYN Flood）？

在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.

SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

SYN 攻击是一种典型的 DoS/DDoS 攻击

#### 如何检测 SYN 攻击？

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

#### 如何防御 SYN 攻击？

SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

### 三次握手原因

因为当`Server`端收到`Client`端的`SYN`连接请求报文后，可以直接发送`SYN+ACK`报文。其中`ACK`报文是用来应答的，`SYN`报文是用来同步的(需要同时确认互相能够收发)



## 四次挥手

TCP的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

![](/home/xsh/桌面/markdown/imgs/100327022731.jpg)



### 第一次挥手FIN_WAIT_1(`FIN=1，seq=x`)

假设客户端想要关闭连接，客户端发送一个 `FIN` 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

### 第二次挥手CLOSE_WAIT(`ACK=1，ACKnum=x+1`)

服务器端确认客户端的 `FIN`包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。

### 第三次挥手LAST_ACK(`FIN=1，seq=y`)

服务器端准备好关闭连接时，向客户端发送结束连接请求，`FIN`置为1。

发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个`ACK`。

### 第四次挥手TIME_WAIT(`ACK=1，ACKnum=y+1`)

客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 `ACK`包。

服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。

客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 `ACK`，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED`状态。



### **关闭连接却是四次握手呢**

关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

### **为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态**

- 第 一，为了保证A发送的最有一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN和ACK 报文段的确认。B会超时重传这个FIN和ACK报文段，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段。接着A重传一次确认。

- 第二，就是防止上面提到的已失效的连接请求报文段出现在本连接中，A在发送完最有一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。一个报是１msl

  所以　fin+ack就是得２msl

![](/home/xsh/桌面/markdown/imgs/30193703-330b281cddc5439f99eb027ac1c9627c.png)

